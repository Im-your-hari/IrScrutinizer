<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!-- Copying and distribution of this file, with or without modification,
     are permitted in any medium without royalty provided the copyright
     notice and this notice are preserved.  This file is offered as-is,
     without any warranty.
-->

<!-- Author: Bengt Martensson -->

<!-- If personalizing this file, consider using xinclude, see the end of the file. -->

<exportformats:exportformats xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
               xmlns:exportformats="http://www.harctoolbox.org/exportformats"
               xmlns:xi="http://www.w3.org/2001/XInclude"
               xsi:schemaLocation="http://www.harctoolbox.org/exportformats http://www.harctoolbox.org/schemas/exportformats.xsd">

<exportformats:exportformat name="RemoteMaster" extension="rmdu" multiSignal="true" simpleSequence="false">
<xsl:stylesheet xmlns:girr="http://www.harctoolbox.org/Girr"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:java="http://xml.apache.org/xalan/java" version="1.0">
    <xsl:output method="text" />

    <xsl:template match="/">
        <xsl:apply-templates select="girr:remotes/girr:remote[1]"/> <!-- just consider the first remote -->
    </xsl:template>

    <xsl:template match="girr:remote">
        <xsl:text># This file was created by IrScrutinizer.
# It is not directly usable in RemoteMaster. For this, make sure that
# protocols.ini contains the "protocol" ImportOnly. Also, check
# Options -> "Allow preserve Control", and then select
# "Preserve: OBC and function parameters" on the "Setup" pane.
# Then open this file with RemoteMaster, and select a sensible executor
# (called protocol in RemoteMaster).
#
# Original protocol: </xsl:text>
        <xsl:value-of select="girr:commandSet[1]//girr:parameters/@protocol"/>
        <xsl:text>
#
Description=</xsl:text>
        <xsl:value-of select="@name"/>
        <xsl:text>
Notes=</xsl:text>
        <xsl:value-of select="@comment"/>
        <xsl:text>\n\nOriginal protocol: </xsl:text>
        <xsl:value-of select="girr:commandSet[1]//girr:parameters/@protocol"/>
        <xsl:text>
Remote.name=URC-7781 One For All Digital 12
Remote.signature=11311131
DeviceType=Cable
DeviceIndex=3
SetupCode=1999
Protocol=99 99
Protocol.name=ImportOnly
ProtocolParms=</xsl:text>
        <xsl:value-of select="girr:commandSet[1]/girr:command[1]/girr:parameters/girr:parameter[@name='D']/@value"/>
        <xsl:text> </xsl:text>
        <xsl:value-of select="girr:commandSet[1]/girr:command[1]/girr:parameters/girr:parameter[@name='S']/@value"/>
        <xsl:text>
</xsl:text>
        <xsl:apply-templates select="girr:commandSet/girr:command"/>
    </xsl:template>

    <xsl:template match="girr:command">
        <xsl:text>Function.</xsl:text>
        <xsl:value-of select="position() - 1"/>
        <xsl:text>.name=</xsl:text>
        <xsl:value-of select="@name"/>
        <xsl:text>
Function.</xsl:text>
        <xsl:value-of select="position() - 1"/>
        <xsl:text>.hex=</xsl:text>
        <xsl:value-of select="java:java.lang.Integer.toHexString(number(girr:parameters/girr:parameter[@name='F']/@value))"/>
        <xsl:apply-templates select="@comment"/>
        <xsl:text>
</xsl:text>

    </xsl:template>

    <xsl:template match="@comment">
        <xsl:text>
Function.</xsl:text>
        <xsl:value-of select="count(../preceding-sibling::girr:command)"/>
        <xsl:text>.notes=</xsl:text>
        <xsl:value-of select="."/>
    </xsl:template>
</xsl:stylesheet>
</exportformats:exportformat>

<exportformats:exportformat name="Arduino Raw" extension="ino" multiSignal="true" simpleSequence="false">
<!-- Limitations:supports only one remote (ignores all but the first one),
     Does not support ending sequences (ignores them).
    -->
<xsl:stylesheet xmlns:girr="http://www.harctoolbox.org/Girr"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:java="http://xml.apache.org/xalan/java"
                xmlns:cidentifierfactory="http://xml.apache.org/xalan/java/org.harctoolbox.irscrutinizer.exporter.CIdentifierFactory"
                version="1.0">
    <xsl:output method="text" />
    <xsl:variable name="cIdentifierFactory" select="cidentifierfactory:new()"/>

    <xsl:template match="/girr:remotes">
        <xsl:text><![CDATA[// This Arduino sketch was automatically generated by IrScrutinizer.

// It supports:
//
// * IRremote https://github.com/z3t0/Arduino-IRremote
//            http://z3t0.github.io/Arduino-IRremote/
// * IRLib    https://github.com/cyborg5/IRLib
// * Infrared4Arduino https://github.com/bengtmartensson/Infrared4Arduino,
//                    http://www.harctoolbox.org/Infrared4Arduino.html (planned)

// For problems, bugs, and suggestions, please open an issue at
// https://github.com/bengtmartensson/harctoolboxbundle/issues

// This file contains C identifiers which have been translated from command names.

// Define exactly one of these
// #define IRREMOTE
// #define IRLIB
#define INFRARED4ARDUINO

/////////////////////////////////////////////////////
// Sanity check
#if defined(IRREMOTE) & ( defined(IRLIB) | defined(INFRARED4ARDUINO) )
#error Must define only one of IRREMOTE, IRLIB, or INFRARED4ARDUINO
#endif

#if defined(IRLIB) & ( defined(IRREMOTE) | defined(INFRARED4ARDUINO) )
#error Must define only one of IRREMOTE, IRLIB, or INFRARED4ARDUINO
#endif

#if defined(INFRARED4ARDUINO) & ( defined(IRLIB) | defined(IRREMOTE) )
#error Must define only one of IRREMOTE, IRLIB, or INFRARED4ARDUINO
#endif

#ifdef IRREMOTE
#include <IRremote.h>
#elif defined(IRLIB)
#include <IRLib.h>
#define sendRaw send
#elif defined(INFRARED4ARDUINO)
#include <IrSenderPwm.h>
#else
#error Must defined one of IRREMOTE, IRLIB, or INFRARED4ARDUINO
#endif

#if defined(IRREMOTE) | defined(IRLIB)
typedef uint16_t microseconds_t; // Change if desired
typedef uint16_t frequency_t;    // Change if desired

static inline unsigned hz2khz(frequency_t f) { return f/1000U; }
#endif

// Constants
static const long BAUD = 115200UL; // Change if desired

// Global variables
#ifdef IRREMOTE
IRsend irsend;
#elif defined(IRLIB)
IRsendRaw irsend;
#else
IrSender *irsend = IrSenderPwm::getInstance(true);
#endif


]]></xsl:text>
<xsl:apply-templates select="girr:remote[1]//girr:command" mode="definition"/>

<xsl:text><![CDATA[
static void sendRaw(const microseconds_t intro_P[], size_t lengthIntro, const microseconds_t repeat_P[],
             size_t lengthRepeat, frequency_t frequency, unsigned times) {
    microseconds_t intro[lengthIntro];
    microseconds_t repeat[lengthRepeat];
    memcpy_PF(intro, (uint_farptr_t) intro_P, sizeof(microseconds_t) * lengthIntro);
    memcpy_PF(repeat, (uint_farptr_t) repeat_P, sizeof(microseconds_t) * lengthRepeat);

#if defined(IRREMOTE) | defined(IRLIB)
    if (lengthIntro > 0U)
        irsend.sendRaw(intro, lengthIntro, hz2khz(frequency));
    if (lengthRepeat > 0U)
        for (unsigned i = 0U; i < times - (lengthIntro > 0U); i++)
            irsend.sendRaw(repeat, lengthRepeat, hz2khz(frequency));
#else // INFRARED4ARDUINO
    IrSignal irSignal(intro, lengthIntro, repeat, lengthRepeat, NULL, 0U, frequency);
    irsend->sendIrSignal(irSignal, times);
#endif
}

void setup() {
    Serial.begin(BAUD);
    Serial.setTimeout(60000UL);
}

// A pretty silly main loop; just intended as an example.
void loop() {
    Serial.println(F("Enter number of signal to send (1 .. ]]></xsl:text>
    <xsl:value-of select="count(//girr:remote[1]//girr:command)"/>
    <xsl:text>)"));
    long commandno = Serial.parseInt();
    Serial.println(F("Enter number of times to send it"));
    long times = Serial.parseInt();
    switch (commandno) {
</xsl:text>
        <xsl:apply-templates select="//girr:remote[1]" mode="using"/>
        <xsl:text>    default:
        Serial.println(F("Invalid number entered, try again"));
        break;
    }
}
</xsl:text>
    </xsl:template>

    <xsl:template match="girr:remote" mode="using">
        <xsl:apply-templates select="//girr:command" mode="using"/>
    </xsl:template>

    <xsl:template match="girr:command" mode="definition">
        <xsl:text>// Command #</xsl:text>
        <xsl:value-of select="position()"/>
        <xsl:text>: </xsl:text>
        <xsl:value-of select="@name"/>
        <xsl:text>
</xsl:text>
        <xsl:apply-templates select="girr:parameters"/>
        <xsl:apply-templates select="girr:raw[1]" mode="definition"/>
        <!--xsl:apply-templates select="girr:ccf"/-->
        <xsl:text>
</xsl:text>
    </xsl:template>

    <xsl:template match="girr:parameters">
        <xsl:text>// Protocol: </xsl:text>
        <xsl:value-of select="@protocol"/>
        <xsl:text>, Parameters:</xsl:text>
        <xsl:apply-templates select="girr:parameter"/>
        <xsl:text>
</xsl:text>
    </xsl:template>

    <xsl:template match="girr:parameter">
        <xsl:text> </xsl:text>
        <xsl:value-of select="@name"/>
        <xsl:text>=</xsl:text>
        <xsl:value-of select="@value"/>
    </xsl:template>

    <xsl:template match="girr:raw" mode="definition">
        <xsl:apply-templates select="*" mode="definition"/>
    </xsl:template>

    <xsl:template match="girr:intro|girr:repeat" mode="definition">
        <xsl:text>const microseconds_t </xsl:text>
        <xsl:value-of select="name(.)"/>
        <xsl:text>_</xsl:text>
        <xsl:value-of select="cidentifierfactory:mkCIdentifier($cIdentifierFactory,
                                                               string(../../@name),
                                                               count(../../preceding-sibling::girr:command))"/>
        <xsl:text>[] PROGMEM = { </xsl:text>
        <xsl:apply-templates select="*"/>
        <xsl:text> };
</xsl:text>
    </xsl:template>

    <xsl:template match="girr:flash">
        <xsl:value-of select="."/>
        <xsl:text>U, </xsl:text>
    </xsl:template>
    <xsl:template match="girr:gap">
        <xsl:value-of select="."/>
        <xsl:text>U, </xsl:text>
    </xsl:template>
    <xsl:template match="girr:gap[position()=last()]">
        <xsl:if test=". &gt; 65535">
            <xsl:text>65535U</xsl:text>
        </xsl:if>
        <xsl:if test=". &lt;= 65535">
            <xsl:value-of select="."/>
        </xsl:if>
    </xsl:template>

    <xsl:template match="girr:command" mode="using">
        <xsl:text>    case </xsl:text>
        <xsl:value-of select="position()"/>
        <xsl:text>U:
</xsl:text>
    <xsl:text>        sendRaw(</xsl:text>
        <xsl:apply-templates select="girr:raw[1]" mode="arg"/>
        <xsl:value-of select="girr:raw[1]/@frequency"/>
        <xsl:text>U, times);
        break;
</xsl:text>
    </xsl:template>

    <xsl:template match="girr:raw" mode="arg">
        <xsl:if test="not(girr:intro)">
            <xsl:text>NULL, 0U, </xsl:text>
        </xsl:if>
        <xsl:apply-templates select="*" mode="arg"/>
        <xsl:if test="not(girr:repeat)">
            <xsl:text>NULL, 0U, </xsl:text>
        </xsl:if>
    </xsl:template>

    <xsl:template match="girr:intro|girr:repeat" mode="arg">
        <xsl:value-of select="name(.)"/>
        <xsl:text>_</xsl:text>
        <xsl:value-of select="cidentifierfactory:mkCIdentifier($cIdentifierFactory,
                                                                string(../../@name),
                                                                count(../../preceding-sibling::girr:command))"/>
        <xsl:text>, </xsl:text>
        <xsl:value-of select="count(*)"/>
        <xsl:text>U, </xsl:text>
    </xsl:template>

    <!-- just to be on the safe side -->
    <xsl:template match="girr:ending">
        <xsl:comment>Warning: ending sequence in command <xsl:value-of select="../../@name"/> was ignored.</xsl:comment>
    </xsl:template>

</xsl:stylesheet>
</exportformats:exportformat>

<exportformats:exportformat name="Arduino/Infrared4Arduino" extension="ino" multiSignal="true" simpleSequence="false">
<!-- Limitations:supports only one remote (ignores all but the first one),
     Does not support ending sequences (ignores them).
    -->
<xsl:stylesheet xmlns:girr="http://www.harctoolbox.org/Girr"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:java="http://xml.apache.org/xalan/java"
                xmlns:cidentifierfactory="http://xml.apache.org/xalan/java/org.harctoolbox.irscrutinizer.exporter.CIdentifierFactory"
                xmlns:exporterutils="http://xml.apache.org/xalan/java/org.harctoolbox.irscrutinizer.exporter.ExporterUtils"
                version="1.0">
    <xsl:output method="text" />
    <xsl:variable name="cIdentifierFactory" select="cidentifierfactory:new()"/>

    <xsl:template match="/">
        <xsl:text><![CDATA[// This Arduino sketch was automatically generated by IrScrutinizer.

// It supports:
//
// * Infrared4Arduino https://github.com/bengtmartensson/Infrared4Arduino,
//                    http://www.harctoolbox.org/Infrared4Arduino.html (planned)

// For problems, bugs, and suggestions, please open an issue at
// https://github.com/bengtmartensson/harctoolboxbundle/issues

// This file contains C identifiers which have been translated from command names.

#include <IrSenderPwm.h>
]]></xsl:text>

<xsl:apply-templates select="//girr:remote[1][//girr:parameters/@protocol='nec1']" mode="includeNec1"/>
<xsl:apply-templates select="//girr:remote[1][//girr:parameters/@protocol='rc5']" mode="includeRc5"/>
<xsl:text>
// Constants
static const long BAUD = 115200UL; // Change if desired

IrSender *irsend = IrSenderPwm::getInstance(true);

</xsl:text>
<xsl:apply-templates select="//girr:remote[1]//girr:command" mode="definition"/>
<xsl:apply-templates select="//girr:remote[1][//girr:parameters/@protocol='nec1']" mode="definitionNec1"/>
<xsl:text>
</xsl:text>
<xsl:apply-templates select="//girr:remote[1][//girr:parameters/@protocol='rc5']" mode="definitionRc5"/>

<xsl:text><![CDATA[
static void sendRaw(const microseconds_t intro_P[], size_t lengthIntro, const microseconds_t repeat_P[],
             size_t lengthRepeat, frequency_t frequency, unsigned times) {
    microseconds_t intro[lengthIntro];
    microseconds_t repeat[lengthRepeat];
    memcpy_PF(intro, (uint_farptr_t) intro_P, sizeof(microseconds_t) * lengthIntro);
    memcpy_PF(repeat, (uint_farptr_t) repeat_P, sizeof(microseconds_t) * lengthRepeat);

    IrSignal irSignal(intro, lengthIntro, repeat, lengthRepeat, NULL, 0U, frequency);
    irsend->sendIrSignal(irSignal, times);
}

void setup() {
    Serial.begin(BAUD);
    Serial.setTimeout(60000UL);
}

// A pretty silly main loop; feel free to replace it by something smarter.
void loop() {
    Serial.println(F("Enter number of signal to send (1 .. ]]></xsl:text>
    <xsl:value-of select="count(//girr:remote[1]//girr:command)"/>
    <xsl:text>)"));
    long commandno = Serial.parseInt();
    Serial.println(F("Enter number of times to send it"));
    long times = Serial.parseInt();
    switch (commandno) {
</xsl:text>
        <xsl:apply-templates select="//girr:remote[1]" mode="using"/>
        <xsl:text>    default:
        Serial.println(F("Invalid number entered, try again"));
        break;
    }
}
</xsl:text>
    </xsl:template>

    <xsl:template match="girr:remote[//girr:parameters/@protocol='nec1']" mode="includeNec1">
        <xsl:text>#include &lt;Nec1Renderer.h&gt;
</xsl:text>
    </xsl:template>

    <xsl:template match="girr:remote[//girr:parameters/@protocol='rc5']" mode="includeRc5">
        <xsl:text>#include &lt;Rc5Renderer.h&gt;
</xsl:text>
    </xsl:template>

    <xsl:template match="girr:remote[//girr:parameters/@protocol='nec1']" mode="definitionNec1">
        <xsl:text>
static void sendNec1(unsigned D, unsigned S, unsigned F, unsigned times) {
    const IrSignal *irSignal = Nec1Renderer::newIrSignal(D, S, F);
    irsend->sendIrSignal(*irSignal, times);
    delete irSignal;
}
</xsl:text>
    </xsl:template>

    <xsl:template match="girr:remote[//girr:parameters/@protocol='rc5']" mode="definitionRc5">
        <xsl:text>
static void sendRc5(unsigned D, unsigned F, unsigned times) {
    const IrSignal *irSignal = Rc5Renderer::newIrSignal(D, F);
    irsend->sendIrSignal(*irSignal, times);
    delete irSignal;
}
</xsl:text>
    </xsl:template>

    <xsl:template match="girr:remote" mode="using">
        <xsl:apply-templates select="//girr:command" mode="using"/>
    </xsl:template>

    <xsl:template match="girr:command" mode="definition">
        <xsl:text>// Command #</xsl:text>
        <xsl:value-of select="position()"/>
        <xsl:text>: </xsl:text>
        <xsl:value-of select="@name"/>
        <xsl:text>
</xsl:text>
        <xsl:apply-templates select="girr:parameters"/>
        <xsl:apply-templates select="girr:raw[1]" mode="definition"/>
        <!--xsl:apply-templates select="girr:ccf"/-->
        <xsl:text>
</xsl:text>
    </xsl:template>

    <xsl:template match="girr:command[girr:parameters[@protocol='nec1' or @protocol='rc5']]" mode="definition">
        <xsl:text>// Command #</xsl:text>
        <xsl:value-of select="position()"/>
        <xsl:text>: </xsl:text>
        <xsl:value-of select="@name"/>
        <xsl:text>
</xsl:text>
        <xsl:apply-templates select="girr:parameters"/>
        <xsl:text>
</xsl:text>
    </xsl:template>

    <xsl:template match="girr:parameters">
        <xsl:text>// Protocol: </xsl:text>
        <xsl:value-of select="@protocol"/>
        <xsl:text>, Parameters:</xsl:text>
        <xsl:apply-templates select="girr:parameter"/>
        <xsl:text>
</xsl:text>
    </xsl:template>

    <xsl:template match="girr:parameter">
        <xsl:text> </xsl:text>
        <xsl:value-of select="@name"/>
        <xsl:text>=</xsl:text>
        <xsl:value-of select="@value"/>
        <xsl:text>U</xsl:text>
    </xsl:template>

    <xsl:template match="girr:raw" mode="definition">
        <xsl:apply-templates select="*" mode="definition"/>
    </xsl:template>

    <xsl:template match="girr:intro|girr:repeat" mode="definition">
        <xsl:text>const microseconds_t </xsl:text>
        <xsl:value-of select="name(.)"/>
        <xsl:text>_</xsl:text>
        <xsl:value-of select="cidentifierfactory:mkCIdentifier($cIdentifierFactory,
                                                               string(../../@name),
                                                               count(../../preceding-sibling::girr:command))"/>
        <xsl:text>[] PROGMEM = { </xsl:text>
        <xsl:apply-templates select="*"/>
        <xsl:text> };
</xsl:text>
    </xsl:template>

    <xsl:template match="girr:flash">
        <xsl:value-of select="."/>
        <xsl:text>U, </xsl:text>
    </xsl:template>
    <xsl:template match="girr:gap">
        <xsl:value-of select="."/>
        <xsl:text>U, </xsl:text>
    </xsl:template>
    <xsl:template match="girr:gap[position()=last()]">
        <xsl:if test=". &gt; 65535">
            <xsl:text>65535U</xsl:text>
        </xsl:if>
        <xsl:if test=". &lt;= 65535">
            <xsl:value-of select="."/>
        </xsl:if>
    </xsl:template>

    <xsl:template match="girr:command" mode="using">
        <xsl:text>    case </xsl:text>
        <xsl:value-of select="position()"/>
        <xsl:text>L:
        sendRaw(</xsl:text>
        <xsl:apply-templates select="girr:raw[1]" mode="arg"/>
        <xsl:value-of select="girr:raw[1]/@frequency"/>
        <xsl:text>U, times);
</xsl:text>
    </xsl:template>


    <!-- version without S -->
    <xsl:template match="girr:command[girr:parameters[@protocol='nec1']]" mode="using">
        <xsl:text>    case </xsl:text>
        <xsl:value-of select="position()"/>
        <xsl:text>L:
        sendNec1(</xsl:text>
        <xsl:apply-templates select="girr:parameters/girr:parameter[@name='D']" mode="arg"/>
        <xsl:value-of select="255 - number(girr:parameters/girr:parameter[@name='D']/@value)"/>
        <xsl:text>U, </xsl:text>
        <xsl:apply-templates select="girr:parameters/girr:parameter[@name='F']" mode="arg"/>
        <xsl:text>times);
        break;
</xsl:text>
    </xsl:template>

    <!-- version with S -->
    <xsl:template match="girr:command[girr:parameters[@protocol='nec1'][girr:parameter/@name='S']]" mode="using">
        <xsl:text>    case </xsl:text>
        <xsl:value-of select="position()"/>
        <xsl:text>L:
        sendNec1(</xsl:text>
        <xsl:apply-templates select="girr:parameters/girr:parameter[@name='D']" mode="arg"/>
        <xsl:apply-templates select="girr:parameters/girr:parameter[@name='S']" mode="arg"/>
        <xsl:apply-templates select="girr:parameters/girr:parameter[@name='F']" mode="arg"/>
        <xsl:text>times);
        break;
</xsl:text>
    </xsl:template>

    <xsl:template match="girr:command[girr:parameters/@protocol='rc5']" mode="using">
        <xsl:text>    case </xsl:text>
        <xsl:value-of select="position()"/>
        <xsl:text>L:
        sendRc5(</xsl:text>
        <xsl:apply-templates select="girr:parameters/girr:parameter[@name='D']" mode="arg"/>
        <xsl:apply-templates select="girr:parameters/girr:parameter[@name='F']" mode="arg"/>
        <xsl:text>times);
        break;
</xsl:text>
    </xsl:template>

    <xsl:template match="girr:parameter" mode="arg">
         <xsl:value-of select="@value"/>
         <xsl:text>U, </xsl:text>
    </xsl:template>


    <xsl:template match="girr:raw" mode="arg">
        <xsl:if test="not(girr:intro)">
            <xsl:text>NULL, 0U, </xsl:text>
        </xsl:if>
        <xsl:apply-templates select="*" mode="arg"/>
        <xsl:if test="not(girr:repeat)">
            <xsl:text>NULL, 0U, </xsl:text>
        </xsl:if>
    </xsl:template>

    <xsl:template match="girr:intro|girr:repeat" mode="arg">
        <xsl:value-of select="name(.)"/>
        <xsl:text>_</xsl:text>
        <xsl:value-of select="cidentifierfactory:mkCIdentifier($cIdentifierFactory,
                                                               string(../../@name),
                                                               count(../../preceding-sibling::girr:command))"/>
        <xsl:text>, </xsl:text>
        <xsl:value-of select="count(*)"/>
        <xsl:text>U, </xsl:text>
    </xsl:template>

    <!-- just to be on the safe side -->
    <xsl:template match="girr:ending">
        <xsl:comment>Warning: ending sequence in command <xsl:value-of select="../../@name"/> was ignored.</xsl:comment>
    </xsl:template>

</xsl:stylesheet>
</exportformats:exportformat>

<exportformats:exportformat name="Arduino/IRremote" extension="ino" multiSignal="true" simpleSequence="false">
<!-- Limitations:supports only one remote (ignores all but the first one),
     Does not support ending sequences (ignores them).
     Does not guarantee that the generated C identifiers will be unique.
    -->
<xsl:stylesheet xmlns:girr="http://www.harctoolbox.org/Girr"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:java="http://xml.apache.org/xalan/java"
                xmlns:cidentifierfactory="http://xml.apache.org/xalan/java/org.harctoolbox.irscrutinizer.exporter.CIdentifierFactory"
                xmlns:exporterutils="http://xml.apache.org/xalan/java/org.harctoolbox.irscrutinizer.exporter.ExporterUtils"
                version="1.0">
    <xsl:output method="text" />
    <xsl:variable name="cIdentifierFactory" select="cidentifierfactory:new()"/>

    <xsl:template match="/">
        <xsl:text><![CDATA[// This Arduino sketch was automatically generated by IrScrutinizer.

// It supports:
//
// * IRremote https://github.com/z3t0/Arduino-IRremote
//            http://z3t0.github.io/Arduino-IRremote/

// For problems, bugs, and suggestions, please open an issue at
// https://github.com/bengtmartensson/harctoolboxbundle/issues

// This file contains C identifiers which have been translated from command names.

/////////////////////////////////////////////////////

#include <IRremote.h>

// Constants
static const long BAUD = 115200UL; // Change if desired

// Global variables
IRsend irsend;
]]></xsl:text>
    <xsl:apply-templates select="//girr:remote[1][//girr:parameters/@protocol='rc5']" mode="defineRc5Toggle"/>
    <xsl:apply-templates select="//girr:remote[1][//girr:parameters/@protocol='rc6']" mode="defineRc6Toggle"/>
    <xsl:apply-templates select="//girr:remote[1][//girr:parameters/@protocol='sony12'
                                 or //girr:parameters/@protocol='sony15'
                                 or //girr:parameters/@protocol='sony20']" mode="defineSonyRepeats"/>
    <xsl:text>
</xsl:text>
    <xsl:apply-templates select="//girr:remote[1]//girr:command" mode="definition"/>
<!--xsl:apply-templates select="//girr:remote[1][//girr:parameters/@protocol='nec1']" mode="definitionNec1"/>
<xsl:text>
</xsl:text>
<xsl:apply-templates select="//girr:remote[1][//girr:parameters/@protocol='rc5']" mode="definitionRc5"/-->

    <xsl:text><![CDATA[
static void sendRaw(const uint16_t data_P[], size_t length, uint16_t frequency) {
    uint16_t data[length];
    memcpy_PF(data, (uint_farptr_t) data_P, sizeof(uint16_t) * length);
    irsend.sendRaw(data, length, frequency);
}

void setup() {
    Serial.begin(BAUD);
    Serial.setTimeout(60000UL);
}

// A pretty silly main loop; feel free to replace it by something smarter.
void loop() {
    Serial.println(F("Enter number of signal to send (1 .. ]]></xsl:text>
    <xsl:value-of select="count(//girr:remote[1]//girr:command)"/>
    <xsl:text>)"));
    long commandno = Serial.parseInt();
    switch (commandno) {
</xsl:text>
        <xsl:apply-templates select="//girr:remote[1]" mode="using"/>
        <xsl:text>    default:
        Serial.println(F("Invalid number entered, try again"));
        break;
    }
}
</xsl:text>
    </xsl:template>

    <xsl:template match="girr:remote" mode="defineRc5Toggle">
        <xsl:text>static unsigned int rc5Toggle = 1; // its complement really
</xsl:text>
    </xsl:template>

    <xsl:template match="girr:remote" mode="defineRc6Toggle">
        <xsl:text>static unsigned int rc6Toggle = 0;
</xsl:text>
    </xsl:template>

    <xsl:template match="girr:remote" mode="defineSonyRepeats">
        <xsl:text>static const unsigned int sonyRepeats = 3U; // change if desired
</xsl:text>
    </xsl:template>


    <xsl:template match="girr:remote" mode="using">
        <xsl:apply-templates select="//girr:command" mode="using"/>
    </xsl:template>

    <xsl:template match="girr:command" mode="definition">
        <xsl:text>// Command #</xsl:text>
        <xsl:value-of select="position()"/>
        <xsl:text>: </xsl:text>
        <xsl:value-of select="@name"/>
        <xsl:text>
</xsl:text>
        <xsl:apply-templates select="girr:parameters"/>
        <xsl:apply-templates select="girr:raw[1]" mode="definition"/>
        <!--xsl:apply-templates select="girr:ccf"/-->
        <xsl:text>
</xsl:text>
    </xsl:template>

    <xsl:template match="girr:command[girr:parameters[@protocol='nec1'
                         or @protocol='rc5' or @protocol='rc6'
                         or @protocol='sony12' or @protocol='sony15' or @protocol='sony20']]"
                  mode="definition">
        <xsl:text>// Command #</xsl:text>
        <xsl:value-of select="position()"/>
        <xsl:text>: </xsl:text>
        <xsl:value-of select="@name"/>
        <xsl:text>
</xsl:text>
        <xsl:apply-templates select="girr:parameters"/>
        <xsl:text>
</xsl:text>
    </xsl:template>

    <xsl:template match="girr:parameters">
        <xsl:text>// Protocol: </xsl:text>
        <xsl:value-of select="@protocol"/>
        <xsl:text>, Parameters:</xsl:text>
        <xsl:apply-templates select="girr:parameter"/>
        <xsl:text>
</xsl:text>
    </xsl:template>

    <xsl:template match="girr:parameter">
        <xsl:text> </xsl:text>
        <xsl:value-of select="@name"/>
        <xsl:text>=</xsl:text>
        <xsl:value-of select="@value"/>
        <xsl:text>U</xsl:text>
    </xsl:template>

    <xsl:template match="girr:raw" mode="definition">
        <xsl:apply-templates select="*" mode="definition"/>
    </xsl:template>

    <xsl:template match="girr:intro|girr:repeat" mode="definition">
        <xsl:text>const uint16_t </xsl:text>
        <xsl:value-of select="name(.)"/>
        <xsl:text>_</xsl:text>
        <xsl:value-of select="cidentifierfactory:mkCIdentifier($cIdentifierFactory,
                                                               string(../../@name),
                                                               count(../../preceding-sibling::girr:command))"/>
        <xsl:text>[] PROGMEM = { </xsl:text>
        <xsl:apply-templates select="*"/>
        <xsl:text> };
</xsl:text>
    </xsl:template>

    <xsl:template match="girr:flash">
        <xsl:value-of select="."/>
        <xsl:text>U, </xsl:text>
    </xsl:template>
    <xsl:template match="girr:gap">
        <xsl:value-of select="."/>
        <xsl:text>U, </xsl:text>
    </xsl:template>
    <xsl:template match="girr:gap[position()=last()]">
        <xsl:if test=". &gt; 65535">
            <xsl:text>65535U</xsl:text>
        </xsl:if>
        <xsl:if test=". &lt;= 65535">
            <xsl:value-of select="."/>
        </xsl:if>
    </xsl:template>

    <!-- Matches commands with not reccognized protocol -->
    <xsl:template match="girr:command" mode="using">
        <xsl:text>    case </xsl:text>
        <xsl:value-of select="position()"/>
        <xsl:text>L:
        sendRaw(</xsl:text>
        <xsl:apply-templates select="girr:raw[1]" mode="arg"/>
        <xsl:value-of select="number(girr:raw[1]/@frequency) div 1000"/>
        <xsl:text>U);
        break;
</xsl:text>
    </xsl:template>


    <!-- version without S -->
    <xsl:template match="girr:command[girr:parameters[@protocol='nec1']]" mode="using">
        <xsl:text>    case </xsl:text>
        <xsl:value-of select="position()"/>
        <xsl:text>L:
        irsend.sendNEC(0x</xsl:text>
        <xsl:value-of select="exporterutils:twoDigitReverseHex(number(girr:parameters/girr:parameter[@name='D']/@value))"/>
        <xsl:value-of select="exporterutils:twoDigitReverseHex(255 - number(girr:parameters/girr:parameter[@name='D']/@value))"/>
        <xsl:value-of select="exporterutils:twoDigitReverseHex(number(girr:parameters/girr:parameter[@name='F']/@value))"/>
        <xsl:value-of select="exporterutils:twoDigitReverseHex(255 - number(girr:parameters/girr:parameter[@name='F']/@value))"/>
        <xsl:text>U, 32);
        break;
</xsl:text>
    </xsl:template>

    <!-- version with S -->
    <xsl:template match="girr:command[girr:parameters[@protocol='nec1'][girr:parameter/@name='S']]" mode="using">
        <xsl:text>    case </xsl:text>
        <xsl:value-of select="position()"/>
        <xsl:text>L:
        irsend.sendNEC(0x</xsl:text>
        <xsl:value-of select="exporterutils:twoDigitReverseHex(number(girr:parameters/girr:parameter[@name='D']/@value))"/>
        <xsl:value-of select="exporterutils:twoDigitReverseHex(number(girr:parameters/girr:parameter[@name='S']/@value))"/>
        <xsl:value-of select="exporterutils:twoDigitReverseHex(number(girr:parameters/girr:parameter[@name='F']/@value))"/>
        <xsl:value-of select="exporterutils:twoDigitReverseHex(255 - number(girr:parameters/girr:parameter[@name='F']/@value))"/>
        <xsl:text>U, 32);
        break;
</xsl:text>
    </xsl:template>


    <xsl:template match="girr:command[girr:parameters/@protocol='rc5']" mode="using">
        <xsl:text>    case </xsl:text>
        <xsl:value-of select="position()"/>
        <xsl:text>L:
        irsend.sendRC5(0x</xsl:text>
        <xsl:value-of select="exporterutils:rc5Data(number(girr:parameters/girr:parameter[@name='D']/@value),number(girr:parameters/girr:parameter[@name='F']/@value),0)"/>
        <xsl:text>U + 0x800U*rc5Toggle, 12U);
        rc5Toggle = 1U - rc5Toggle;
        break;
</xsl:text>
    </xsl:template>

    <xsl:template match="girr:command[girr:parameters/@protocol='rc6']" mode="using">
        <xsl:text>    case </xsl:text>
        <xsl:value-of select="position()"/>
        <xsl:text>L:
        irsend.sendRC6(0x</xsl:text>
        <xsl:value-of select="exporterutils:twoDigitHex(number(girr:parameters/girr:parameter[@name='D']/@value))"/>
        <xsl:value-of select="exporterutils:twoDigitHex(number(girr:parameters/girr:parameter[@name='F']/@value))"/>
        <xsl:text>U + 0x10000U*rc6Toggle, 20U);
        rc6Toggle = 1U - rc6Toggle;
        break;
</xsl:text>
    </xsl:template>

   <xsl:template match="girr:command[girr:parameters/@protocol='sony12']" mode="using">
        <xsl:text>    case </xsl:text>
        <xsl:value-of select="position()"/>
        <xsl:text>L:
        for (unsigned i = 0; i &lt; sonyRepeats; i++) {
            irsend.sendSony(0x</xsl:text>
        <xsl:value-of select="exporterutils:sony12Data(number(girr:parameters/girr:parameter[@name='D']/@value),
                                                       number(girr:parameters/girr:parameter[@name='F']/@value))"/>
        <xsl:text>U, 12U);
            delay(21U);
        }
        break;
</xsl:text>
   </xsl:template>

   <xsl:template match="girr:command[girr:parameters/@protocol='sony15']" mode="using">
        <xsl:text>    case </xsl:text>
        <xsl:value-of select="position()"/>
        <xsl:text>L:
        for (unsigned i = 0; i &lt; sonyRepeats; i++) {
            irsend.sendSony(0x</xsl:text>
        <xsl:value-of select="exporterutils:sony15Data(number(girr:parameters/girr:parameter[@name='D']/@value),
                                                       number(girr:parameters/girr:parameter[@name='F']/@value))"/>
        <xsl:text>U, 15U);
            delay(21U);
        }
        break;
</xsl:text>
   </xsl:template>

   <xsl:template match="girr:command[girr:parameters/@protocol='sony20']" mode="using">
        <xsl:text>    case </xsl:text>
        <xsl:value-of select="position()"/>
        <xsl:text>L:
        for (unsigned i = 0; i &lt; sonyRepeats; i++) {
            irsend.sendSony(0x</xsl:text>
        <xsl:value-of select="exporterutils:sony20Data(number(girr:parameters/girr:parameter[@name='D']/@value),
                                                       number(girr:parameters/girr:parameter[@name='S']/@value),
                                                       number(girr:parameters/girr:parameter[@name='F']/@value))"/>
        <xsl:text>U, 20U);
            delay(21U);
        }
        break;
</xsl:text>
   </xsl:template>

    <xsl:template match="girr:parameter" mode="arg">
         <xsl:value-of select="@value"/>
         <xsl:text>U, </xsl:text>
    </xsl:template>


    <xsl:template match="girr:raw" mode="arg">
        <xsl:apply-templates select="girr:intro" mode="arg"/>
        <xsl:if test="not(girr:intro)">
            <xsl:apply-templates select="girr:repeat" mode="arg"/>
        </xsl:if>
    </xsl:template>

    <xsl:template match="girr:intro|girr:repeat" mode="arg">
        <xsl:value-of select="name(.)"/>
        <xsl:text>_</xsl:text>
        <xsl:value-of select="cidentifierfactory:mkCIdentifier($cIdentifierFactory,
                                                               string(../../@name),
                                                               count(../../preceding-sibling::girr:command))"/>
        <xsl:text>, </xsl:text>
        <xsl:value-of select="count(*)"/>
        <xsl:text>U, </xsl:text>
    </xsl:template>

    <!-- just to be on the safe side -->
    <xsl:template match="girr:ending">
        <xsl:comment>Warning: ending sequence in command <xsl:value-of select="../../@name"/> was ignored.</xsl:comment>
    </xsl:template>

</xsl:stylesheet>
</exportformats:exportformat>

<exportformats:exportformat name="C" extension="c" multiSignal="true" simpleSequence="false">
<xsl:stylesheet xmlns:girr="http://www.harctoolbox.org/Girr"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
    <xsl:output method="text" />

    <xsl:template match="/girr:remotes">
        <xsl:text>/* This file was automatically generated by IrScrutinizer */

const int frequency = </xsl:text>
<xsl:value-of select="girr:remote/girr:commandSet/girr:command/girr:raw/@frequency"/><xsl:text>;
</xsl:text>
<xsl:text>const char *protocol = "</xsl:text><xsl:value-of select="girr:remote/girr:commandSet/girr:command/girr:parameters/@protocol"/><xsl:text>";
</xsl:text>
<xsl:text>const int intro_burst_length = </xsl:text><xsl:value-of select="count(girr:remote/girr:commandSet/girr:command[1]/girr:raw/girr:intro/girr:flash)"/>
<xsl:text>;
const int repeat_burst_length = </xsl:text><xsl:value-of select="count(girr:remote/girr:commandSet/girr:command[1]/girr:raw/girr:repeat/girr:flash)"/>
<xsl:text>;
const int ending_burst_length = </xsl:text><xsl:value-of select="count(girr:remote/girr:commandSet/girr:command[1]/girr:raw/girr:ending/girr:flash)"/>
<xsl:text>;

</xsl:text>
        <xsl:apply-templates select="//girr:command" mode="ccf"/>

        <xsl:apply-templates select="//girr:command" mode="raw"/>
    </xsl:template>

    <xsl:template match="girr:command" mode="ccf">
<xsl:text>/* Signal D = </xsl:text>
        <xsl:value-of select="girr:parameters/girr:parameter[@name='D']/@value"/>
        <xsl:text>; S = </xsl:text>
        <xsl:value-of select="girr:parameters/girr:parameter[@name='S']/@value"/>
        <xsl:text>; F = </xsl:text>
        <xsl:value-of select="girr:parameters/girr:parameter[@name='F']/@value"/>
        <xsl:text> */
const char *pronto_</xsl:text>
        <xsl:value-of select="girr:parameters/@protocol"/>
        <xsl:text>_</xsl:text>
        <xsl:value-of select="girr:parameters/girr:parameter[@name='D']/@value"/>
        <xsl:text>_</xsl:text>
        <xsl:value-of select="girr:parameters/girr:parameter[@name='S']/@value"/>
        <xsl:text>_</xsl:text>
        <xsl:value-of select="girr:parameters/girr:parameter[@name='F']/@value"/>
        <xsl:text> = "</xsl:text>
        <xsl:value-of select="girr:ccf"/>
        <xsl:text>";
</xsl:text>
    </xsl:template>

    <xsl:template match="girr:command" mode="raw">
       <xsl:text>const int raw_</xsl:text>
        <xsl:value-of select="girr:parameters/@protocol"/>
        <xsl:text>_</xsl:text>
        <xsl:value-of select="girr:parameters/girr:parameter[@name='D']/@value"/>
        <xsl:text>_</xsl:text>
        <xsl:value-of select="girr:parameters/girr:parameter[@name='S']/@value"/>
        <xsl:text>_</xsl:text>
        <xsl:value-of select="girr:parameters/girr:parameter[@name='F']/@value"/>
        <xsl:text>[] = { </xsl:text>
        <xsl:apply-templates select="girr:raw[1]"/>
        <xsl:text> };
</xsl:text>
    </xsl:template>

    <xsl:template match="girr:raw">
        <xsl:apply-templates select="*/*"/>
    </xsl:template>

    <xsl:template match="girr:flash|girr:gap"><xsl:value-of select="."/><xsl:text>,</xsl:text></xsl:template>

     <xsl:template match="girr:raw/*[position()=last()]/girr:gap[position()=last()]"><xsl:value-of select="."/></xsl:template>
</xsl:stylesheet>
</exportformats:exportformat>

<exportformats:exportformat name="Lintronic" extension="txt" multiSignal="false" simpleSequence="true">
<xsl:stylesheet xmlns:girr="http://www.harctoolbox.org/Girr"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
    <!--xsl:param name="noRepeats" select="4"/-->
    <xsl:output method="text" />

    <xsl:template match="/girr:remotes">
        <xsl:text>Pulse, Pause in micro-seconds
</xsl:text>
<xsl:apply-templates select="girr:remote[1]/girr:commandSet[1]/girr:command[1]"/>
    </xsl:template>

    <xsl:template match="girr:command">
        <xsl:apply-templates select="girr:raw[1]"/>
    </xsl:template>

    <xsl:template match="girr:raw">
        <xsl:apply-templates select="girr:intro/*"/>
        <xsl:call-template name="girr:repeat"/>
        <xsl:apply-templates select="girr:ending/*"/>
    </xsl:template>

    <xsl:template name="girr:repeat">
         <xsl:param name="n" select="number($noRepeats)"/>
         <xsl:if test="not($n = 1)">
             <xsl:call-template name="girr:repeat">
                 <xsl:with-param name="n" select="$n - 1"/>
             </xsl:call-template>
         </xsl:if>
         <xsl:apply-templates select="girr:repeat/*"/>
    </xsl:template>

    <xsl:template match="girr:flash"><xsl:value-of select='format-number(number(.),"00000")'/><xsl:text>,</xsl:text></xsl:template>
     <xsl:template match="girr:gap"><xsl:text></xsl:text><xsl:value-of select='format-number(number(.),"00000")'/><xsl:text> = </xsl:text><xsl:value-of select='format-number(number(.)+number(preceding-sibling::girr:flash[1]), "00000")'/><xsl:text>
</xsl:text></xsl:template>

</xsl:stylesheet>
</exportformats:exportformat>


<exportformats:exportformat name="IRTrans" extension="rem" multiSignal="true" simpleSequence="false">
<xsl:stylesheet xmlns:girr="http://www.harctoolbox.org/Girr"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
    <xsl:output method="text" />
    <xsl:template match="/">
        <xsl:apply-templates select="girr:remotes/girr:remote[1]"/>
    </xsl:template>

    <xsl:template match="girr:remote">
        <xsl:text>[REMOTE]
 [NAME]ccf_</xsl:text>
        <xsl:value-of select="@name"/>
        <xsl:text>

[COMMANDS]
</xsl:text>
        <xsl:apply-templates select="girr:commandSet/girr:command"/>
    </xsl:template>

    <xsl:template match="girr:command">
      <xsl:text> [</xsl:text>
      <xsl:value-of select="@name"/>
      <xsl:text>][CCF]</xsl:text>
      <xsl:value-of select="girr:ccf"/>
      <xsl:text>
</xsl:text>
    </xsl:template>

</xsl:stylesheet>
</exportformats:exportformat>

<exportformats:exportformat name="TV B Gone" extension="c" multiSignal="true" simpleSequence="false">
<xsl:stylesheet xmlns:girr="http://www.harctoolbox.org/Girr"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
    <xsl:output method="text" />

    <xsl:template match="/">
        <xsl:apply-templates select="girr:remotes/girr:remote/girr:commandSet/girr:command"/>
    </xsl:template>

    <xsl:template match="girr:command">
        <xsl:text>const struct powercode </xsl:text>
        <xsl:value-of select="@name"/>
        <xsl:text> PROGMEM = {
   freq_to_timerval(</xsl:text>
        <xsl:value-of select="girr:raw[1]/@frequency"/>
        <xsl:text>),
   {
</xsl:text>
        <xsl:apply-templates select="girr:raw[1]/*/*"/>
        <!--xsl:apply-templates select="command[1]"/-->
        <xsl:text>   }
};
</xsl:text>
    </xsl:template>

    <!--xsl:template match="girr:command">
    <xsl:apply-templates select="girr:raw/*/*"/>
    </xsl:template-->

    <xsl:template match="girr:flash">
      <xsl:text>      { </xsl:text>
      <xsl:value-of select="round(number(.) div 10)"/>
      <xsl:text>, </xsl:text>
     </xsl:template>

    <xsl:template match="girr:gap">
      <xsl:value-of select="round(number(.) div 10)"/>
      <xsl:text> },
</xsl:text>
     </xsl:template>

</xsl:stylesheet>
</exportformats:exportformat>

<exportformats:exportformat name="Spreadsheet" extension="csv" multiSignal="true" simpleSequence="false">
    <xsl:stylesheet xmlns:girr="http://www.harctoolbox.org/Girr"
                    xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
        <xsl:output method="text" />

        <xsl:template match="/">
            <xsl:apply-templates select="girr:remotes/girr:remote/girr:commandSet/girr:command"/>
        </xsl:template>

        <xsl:template match="girr:command">
            <xsl:value-of select="@name"/>
            <xsl:text>&#9;</xsl:text>
            <xsl:value-of select="girr:parameters/@protocol"/>
            <xsl:text>&#9;</xsl:text>
            <xsl:value-of select="girr:parameters/girr:parameter[@name='D']/@value"/>
            <xsl:text>&#9;</xsl:text>
            <xsl:value-of select="girr:parameters/girr:parameter[@name='S']/@value"/>
            <xsl:text>&#9;</xsl:text>
            <xsl:value-of select="girr:parameters/girr:parameter[@name='F']/@value"/>
            <xsl:text>&#9;</xsl:text>
            <xsl:value-of select="girr:parameters/girr:parameter[@name='T']/@value"/>
            <xsl:text>&#9;</xsl:text>
            <xsl:apply-templates select="girr:parameters/girr:parameter[not(@name='F' or @name='D' or @name='S' or @name='T')]"/>
            <xsl:text>&#9;</xsl:text>
            <xsl:value-of select="girr:raw/@frequency"/>
            <xsl:text>&#9;</xsl:text>
            <xsl:apply-templates select="girr:raw[1]/girr:intro[1]/*"/>
            <xsl:text>&#9;</xsl:text>
            <xsl:apply-templates select="girr:raw[1]/girr:repeat[1]/*"/>
            <xsl:text>&#9;</xsl:text>
            <xsl:apply-templates select="girr:raw[1]/girr:ending[1]/*"/>
            <xsl:text>&#9;</xsl:text>
            <xsl:value-of select="girr:ccf"/>
            <xsl:text>&#9;</xsl:text>
            <xsl:value-of select="@comment"/>
            <xsl:text>
</xsl:text>
        </xsl:template>

        <xsl:template match="girr:parameter">
            <xsl:value-of select="@name"/>
            <xsl:text>=</xsl:text>
            <xsl:value-of select="@value"/>
            <xsl:if test="position()!=last()">
                <xsl:text> </xsl:text>
            </xsl:if>
        </xsl:template>

        <xsl:template match="girr:flash">
            <xsl:text>+</xsl:text>
            <xsl:value-of select="."/>
            <xsl:text> </xsl:text>
        </xsl:template>
        <xsl:template match="girr:gap">
            <xsl:text>-</xsl:text>
            <xsl:value-of select="."/>
            <xsl:if test="position()!=last()">
                <xsl:text> </xsl:text>
            </xsl:if>
        </xsl:template>

    </xsl:stylesheet>
</exportformats:exportformat>

<!-- Obsolete -->
<!--exportformats:exportformat name="RMFunctions" extension="tsv" multiSignal="true" simpleSequence="false">
    <xsl:stylesheet xmlns:girr="http://www.harctoolbox.org/Girr"
                    xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
        <xsl:output method="text" />

        <xsl:template match="/">
            <xsl:apply-templates select="girr:remotes/girr:remote/girr:commandSet/girr:command"/>
        </xsl:template>

        <xsl:template match="girr:command">
            <xsl:value-of select="@name"/>
            <xsl:text>&#9;</xsl:text>
            <xsl:text>&#9;</xsl:text>
            <xsl:value-of select="girr:parameters/girr:parameter[@name='F']/@value"/>
            <xsl:text>&#9;</xsl:text>
            <xsl:text>&#9;</xsl:text>
            <xsl:value-of select="@comment"/>
            <xsl:text>
</xsl:text>
        </xsl:template>

    </xsl:stylesheet>
</exportformats:exportformat-->

<exportformats:exportformat name="ICT" extension="ict" multiSignal="true" simpleSequence="false">
    <xsl:stylesheet xmlns:girr="http://www.harctoolbox.org/Girr"
                    xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
        <xsl:output method="text" />
        <xsl:template match="/girr:remotes">
            <xsl:text>irscope 0
carrier_frequency </xsl:text>
            <xsl:value-of select="girr:remote/girr:commandSet/girr:command/girr:raw/@frequency"/>
            <xsl:text>
</xsl:text>
            <xsl:text>sample_count </xsl:text>
            <xsl:value-of select="count(girr:remote/girr:commandSet/girr:command/girr:raw/*/*)"/>
            <xsl:text>
</xsl:text>
            <xsl:apply-templates select="//girr:command"/>
        </xsl:template>

        <xsl:template match="girr:command">
            <xsl:text>note=</xsl:text>
            <xsl:value-of select="@name"/>
            <xsl:text>
</xsl:text>
            <xsl:apply-templates select="girr:raw[1]/*"/>
        </xsl:template>

        <xsl:template match="girr:intro|girr:repeat|girr:ending">
            <xsl:apply-templates select="*"/>
        </xsl:template>

        <xsl:template match="girr:flash">
            <xsl:text>+</xsl:text>
            <xsl:value-of select="."/>
            <xsl:text>,</xsl:text>
            <xsl:value-of select="round(number(.) * number(../../@frequency div 1000000))"/>
            <xsl:text>
</xsl:text>
        </xsl:template>

        <xsl:template match="girr:gap">
       <xsl:text>-</xsl:text>
            <xsl:value-of select="."/>
            <xsl:text>
</xsl:text>
        </xsl:template>

        <!-- There is a bug/design flaw in IrScope that makes it want to bundle all
        signals into one gigantic macro. Using brute force to circumvent... -->
        <xsl:template match="girr:gap[position()=last()]">
     <xsl:text>-500000
</xsl:text>
        </xsl:template>

    </xsl:stylesheet>
</exportformats:exportformat>

<exportformats:exportformat name="IrToy" extension="txt" multiSignal="false" simpleSequence="true">
<xsl:stylesheet xmlns:girr="http://www.harctoolbox.org/Girr"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
    <!--xsl:param name="noRepeats" select="4"/-->
    <xsl:param name="period" select="21.3333"/>
    <xsl:output method="text" />

    <xsl:template match="/">
        <xsl:apply-templates select="girr:remotes"/>
    </xsl:template>

    <xsl:template match="girr:remotes">
        <xsl:apply-templates select="girr:remote[1]/girr:commandSet[1]/girr:command[1]"/>
    </xsl:template>

    <xsl:template match="girr:command">
        <xsl:apply-templates select="girr:raw[1]"/>
    </xsl:template>

    <xsl:template match="girr:raw">
        <xsl:apply-templates select="girr:intro/*"/>
        <xsl:if test="$noRepeats > 0">
            <xsl:call-template name="girr:repeat"/>
        </xsl:if>
        <xsl:apply-templates select="girr:ending/*"/>
    </xsl:template>

    <xsl:template name="girr:repeat">
         <xsl:param name="n" select="number($noRepeats)"/>
          <xsl:if test="not($n = 1)">
              <xsl:call-template name="girr:repeat">
                 <xsl:with-param name="n" select="$n - 1"/>
             </xsl:call-template>
         </xsl:if>
         <xsl:apply-templates select="girr:repeat/*"/>
    </xsl:template>

    <xsl:template match="girr:gap|girr:flash">
        <xsl:variable name="periods" select="floor(number(.) div $period)"/>
    <xsl:call-template name="hexnum">
        <xsl:with-param name="value" select="floor($periods div 256)"/>
    </xsl:call-template>
    <xsl:call-template name="hexnum">
        <xsl:with-param name="value" select="$periods mod 256"/>
    </xsl:call-template>
    </xsl:template>

    <xsl:template name="hexnum">
        <xsl:param name="value"/>
        <xsl:call-template name="hexdigit">
            <xsl:with-param name="val" select="floor($value div 16)"/>
        </xsl:call-template>
        <xsl:call-template name="hexdigit">
            <xsl:with-param name="val" select="$value mod 16"/>
        </xsl:call-template>
        <xsl:text> </xsl:text>
    </xsl:template>

    <xsl:template name="hexdigit">
        <xsl:param name="val"/>
           <xsl:value-of select="substring('0123456789ABCDEF',$val+1,1)"/>
        </xsl:template>
</xsl:stylesheet>
</exportformats:exportformat>

<exportformats:exportformat name="IrToy-bin" binary="true" extension="bin" multiSignal="false" simpleSequence="true">
<xsl:stylesheet xmlns:girr="http://www.harctoolbox.org/Girr"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0"
                exclude-result-prefixes="girr">
    <!--xsl:param name="noRepeats" select="2"/-->
    <xsl:param name="period" select="21.3333"/>
    <xsl:output method="xml"/>

    <xsl:template match="/girr:remotes">
        <root> <!-- Just any element as root -->
            <xsl:apply-templates select="girr:remote[1]/girr:commandSet[1]/girr:command[1]"/>
        </root>
    </xsl:template>

    <xsl:template match="girr:command">
        <xsl:apply-templates select="girr:raw[1]"/>
    </xsl:template>

    <xsl:template match="girr:raw">
        <xsl:apply-templates select="girr:intro/*"/>
        <xsl:if test="$noRepeats > 0">
        <xsl:call-template name="girr:repeat"/>
        </xsl:if>
        <xsl:apply-templates select="girr:ending/*"/>
    </xsl:template>

    <xsl:template name="girr:repeat">
         <xsl:param name="n" select="number($noRepeats)"/>
         <xsl:if test="not($n = 1)">
             <xsl:call-template name="girr:repeat">
                 <xsl:with-param name="n" select="$n - 1"/>
             </xsl:call-template>
         </xsl:if>
         <xsl:apply-templates select="girr:repeat/*"/>
    </xsl:template>

    <xsl:template match="girr:gap|girr:flash">
        <xsl:variable name="periods" select="floor(number(.) div $period)"/>
    <xsl:call-template name="hexnum">
        <xsl:with-param name="value" select="floor($periods div 256)"/>
    </xsl:call-template>
    <xsl:call-template name="hexnum">
        <xsl:with-param name="value" select="$periods mod 256"/>
    </xsl:call-template>
    </xsl:template>

    <xsl:template name="hexnum">
        <xsl:param name="value"/>
        <byte>
            <xsl:value-of select="$value"/>
        </byte>
        <xsl:text>
</xsl:text>
    </xsl:template>
</xsl:stylesheet>
</exportformats:exportformat>

<exportformats:exportformat name="mode2" extension="mode2" multiSignal="false" simpleSequence="true">
    <xsl:stylesheet xmlns:girr="http://www.harctoolbox.org/Girr"
                    xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
        <!--xsl:param name="noRepeats" select="4"/-->
        <xsl:output method="text" />

        <xsl:template match="/girr:remotes">
            <xsl:apply-templates select="girr:remote[1]/girr:commandSet[1]/girr:command[1]"/>
        </xsl:template>

        <xsl:template match="girr:command">
            <xsl:apply-templates select="girr:raw[1]"/>
        </xsl:template>

        <xsl:template match="girr:raw">
            <xsl:apply-templates select="girr:intro/*"/>
            <xsl:call-template name="girr:repeat"/>
            <xsl:apply-templates select="girr:ending/*"/>
        </xsl:template>

        <xsl:template name="girr:repeat">
            <xsl:param name="n" select="number($noRepeats)"/>
            <xsl:if test="not($n = 1)">
                <xsl:call-template name="girr:repeat">
                    <xsl:with-param name="n" select="$n - 1"/>
                </xsl:call-template>
            </xsl:if>
            <xsl:apply-templates select="girr:repeat/*"/>
        </xsl:template>

        <xsl:template match="girr:flash">
            <xsl:text>pulse </xsl:text>
            <xsl:value-of select='.'/>
            <xsl:text>
</xsl:text>
        </xsl:template>
        <xsl:template match="girr:gap">
            <xsl:text>space </xsl:text>
            <xsl:value-of select='.'/>
            <xsl:text>
</xsl:text>
        </xsl:template>

    </xsl:stylesheet>
</exportformats:exportformat>

<exportformats:exportformat name="AnyMote" extension="amsr" multiSignal="true" simpleSequence="false">
    <xsl:stylesheet xmlns:girr="http://www.harctoolbox.org/Girr"
                    xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
        <xsl:output method="text" />
        <xsl:strip-space elements="*" />

        <xsl:template match="girr:remote[1]">
            <xsl:text>{"name":"</xsl:text>
            <xsl:value-of select="@remoteName"/>
            <xsl:text>","all_codes":[</xsl:text>
            <xsl:apply-templates select="girr:commandSet/girr:command"/>
            <xsl:text>]}</xsl:text>
        </xsl:template>

        <xsl:template match="girr:command">
            <xsl:text>{"function":"</xsl:text>
            <xsl:value-of select="@name"/>
            <xsl:text>","code1":"</xsl:text>
            <xsl:apply-templates select="girr:raw[1]"/>
            <xsl:text>"}</xsl:text>
            <xsl:if test="position()!=last()">
                <xsl:text>,</xsl:text>
            </xsl:if>
        </xsl:template>

        <xsl:template match="girr:raw">
            <xsl:value-of select="@frequency"/>
            <xsl:text>,</xsl:text>
            <xsl:apply-templates select="node()/node()"/>
        </xsl:template>

        <xsl:template match="girr:flash|girr:gap">
            <xsl:value-of select="round(number(.) * number(../../@frequency) div 1000000)"/>
            <xsl:if test="position()!=last()">
                <xsl:text>,</xsl:text>
            </xsl:if>
        </xsl:template>

    </xsl:stylesheet>
</exportformats:exportformat>

<exportformats:exportformat name="irplus" extension="irplus" multiSignal="true" simpleSequence="false" metadata="true">
<xsl:stylesheet xmlns:girr="http://www.harctoolbox.org/Girr" exclude-result-prefixes="girr"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
    <xsl:output method="xml" indent="yes" omit-xml-declaration="yes"/>

    <xsl:template match="/girr:remotes">
        <irplus>
            <xsl:comment>This file was automatically generated by IrScrutinizer</xsl:comment>
            <xsl:apply-templates select="girr:remote"/>
        </irplus>
    </xsl:template>

    <xsl:template match="girr:remote">
        <device>
            <xsl:attribute name="manufacturer">
                <xsl:value-of select="@manufacturer"/>
                <xsl:if test="not(@manufacturer)">unknown manufacturer</xsl:if>
            </xsl:attribute>
            <xsl:attribute name="model">
                <xsl:value-of select="@model"/>
                <xsl:if test="not(@model)">unknown model</xsl:if>
            </xsl:attribute>
            <xsl:attribute name="format">PRONTO_HEX</xsl:attribute>
            <!--xsl:attribute name="columns">3</xsl:attribute--> <!-- uncomment if desired -->
            <xsl:apply-templates select="girr:commandSet/girr:command"/>
        </device>
    </xsl:template>

    <xsl:template match="girr:command">
        <button>
            <xsl:attribute name="label">
                <xsl:value-of select="@name"/>
            </xsl:attribute>
            <xsl:apply-templates select="girr:ccf"/>
        </button>
    </xsl:template>

    <xsl:template match="girr:ccf">
        <xsl:text>|</xsl:text>
        <xsl:value-of select="."/>
    </xsl:template>

    <xsl:template match="girr:ccf[1]">
        <xsl:value-of select="."/>
    </xsl:template>
</xsl:stylesheet>

</exportformats:exportformat>

<exportformats:exportformat name="Lirc" extension="lircd.conf" multiSignal="true" simpleSequence="false" metadata="true">
<xsl:stylesheet xmlns:girr="http://www.harctoolbox.org/Girr"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:java="http://xml.apache.org/xalan/java"
                xmlns:cidentifierfactory="http://xml.apache.org/xalan/java/org.harctoolbox.irscrutinizer.exporter.CIdentifierFactory"
                xmlns:exporterutils="http://xml.apache.org/xalan/java/org.harctoolbox.irscrutinizer.exporter.ExporterUtils"
                version="1.0">
    <xsl:output method="text" />

    <xsl:template match="/girr:remotes">
        <xsl:text># </xsl:text><xsl:value-of select="@title"/>
<xsl:text>
#
# Creating tool: </xsl:text><xsl:value-of select="$creatingTool"/>
<xsl:text>
# Creating user: </xsl:text><xsl:value-of select="$creatingUser"/>
<xsl:text>
# Creating date: </xsl:text><xsl:value-of select="$creatingDate"/>
<xsl:text>
# Encoding: </xsl:text><xsl:value-of select="$encoding"/>
<xsl:text>
#
</xsl:text>
        <xsl:apply-templates select="girr:remote"/>
    </xsl:template>

    <xsl:template match="girr:remote">
        <xsl:text># Manufacturer: </xsl:text>
            <xsl:value-of select="@manufacturer"/>
<xsl:text>
# Model: </xsl:text>
         <xsl:value-of select="@model"/>
<xsl:text>
# Displayname: </xsl:text><xsl:value-of select="@displayName"/>
<xsl:text>
# Remotename: </xsl:text><xsl:value-of select="@remoteName"/>
<xsl:text>
#
</xsl:text>
    <xsl:apply-templates select="girr:commandSet"/>
    </xsl:template>

<!-- General case, raw codes -->
    <xsl:template match="girr:commandSet">
        <xsl:text>begin remote
&#9;name&#9;</xsl:text><xsl:value-of select="../@name"/>
<xsl:text>
&#9;flags&#9;RAW_CODES
&#9;eps&#9;30
&#9;aeps&#9;100
&#9;frequency&#9;</xsl:text><xsl:value-of select="//girr:command[1]/girr:raw/@frequency"/>
<xsl:text>
&#9;gap&#9;</xsl:text>
<xsl:value-of select="//girr:command[1]/girr:raw/girr:repeat/girr:gap[position()=last()]"/>
<xsl:text>
&#9;begin raw_codes
</xsl:text>
<xsl:apply-templates select="//girr:command"/>
<xsl:text>&#9;end raw_codes
end remote
</xsl:text>
</xsl:template>

    <xsl:template match="girr:command">
        <xsl:text>&#9;&#9;name </xsl:text>
        <xsl:value-of select="@name"/>
        <xsl:text>
</xsl:text>
        <xsl:apply-templates select="girr:raw[1]"/>
        <xsl:text>
</xsl:text>
    </xsl:template>

    <xsl:template match="girr:raw">
        <xsl:apply-templates select="girr:intro"/>
        <xsl:if test="not(girr:intro)">
            <xsl:apply-templates select="girr:repeat"/>
        </xsl:if>
    </xsl:template>

    <xsl:template match="girr:intro|girr:repeat">
        <xsl:text>&#9;&#9;&#9;</xsl:text>
       <xsl:apply-templates select="*"/>
    </xsl:template>

    <xsl:template match="girr:flash">
        <xsl:value-of select="."/>
        <xsl:text> </xsl:text>
    </xsl:template>

    <xsl:template match="girr:gap">
        <xsl:value-of select="."/>
        <xsl:text> </xsl:text>
    </xsl:template>

    <xsl:template match="girr:gap[position() mod 4 = 0]">
        <xsl:value-of select="."/>
        <xsl:text>
&#9;&#9;&#9;</xsl:text>
    </xsl:template>

    <xsl:template match="girr:gap[position()=last()]"/>

    <!-- NEC1 -->
    <xsl:template match="girr:commandSet[girr:command/girr:parameters/@protocol = 'nec1']">
        <xsl:text>begin remote
&#9;name&#9;</xsl:text>
        <xsl:value-of select="../@name"/>
        <xsl:text>
&#9;bits&#9;32
&#9;flags&#9;SPACE_ENC|CONST_LENGTH
&#9;eps&#9;30
&#9;aeps&#9;100
&#9;zero&#9;573&#9;573
&#9;one&#9;573&#9;1694
&#9;header&#9;9041&#9;4507
&#9;ptrail&#9;573
&#9;repeat&#9;9041&#9;2267
&#9;gap&#9;108000
&#9;repeat_bit&#9;0
&#9;frequency&#9;38400
&#9;begin codes
        </xsl:text>
        <xsl:apply-templates select="//girr:command"/>
        <xsl:text>&#9;end codes
            end remote
        </xsl:text>
    </xsl:template>

    <xsl:template match="girr:command[girr:parameters/@protocol='nec1']">
        <xsl:text>&#9;&#9;</xsl:text>
        <xsl:value-of select="@name"/>
        <xsl:text>&#9;0x</xsl:text>
        <xsl:value-of select="exporterutils:processBitFields(
                                    false(), true(), number(girr:parameters/girr:parameter[@name='D']/@value), 8, 0,
                                    true(),  true(), number(girr:parameters/girr:parameter[@name='D']/@value), 8, 0,
                                    false(), true(), number(girr:parameters/girr:parameter[@name='F']/@value), 8, 0,
                                    true(),  true(), number(girr:parameters/girr:parameter[@name='F']/@value), 8, 0)"/>
        <xsl:text>
        </xsl:text>
    </xsl:template>

    <xsl:template match="girr:command[girr:parameters[@protocol='nec1'  and ./girr:parameter/@name='S']]">
        <xsl:text>&#9;&#9;</xsl:text>
        <xsl:value-of select="@name"/>
        <xsl:text>&#9;0x</xsl:text>
       <xsl:value-of select="exporterutils:processBitFields(
                                    false(), true(), number(girr:parameters/girr:parameter[@name='D']/@value), 8, 0,
                                    false(),  true(), number(girr:parameters/girr:parameter[@name='S']/@value), 8, 0,
                                    false(), true(), number(girr:parameters/girr:parameter[@name='F']/@value), 8, 0,
                                    true(),  true(), number(girr:parameters/girr:parameter[@name='F']/@value), 8, 0)"/>
        <xsl:text>
        </xsl:text>
    </xsl:template>

    <!-- RC5 -->
    <xsl:template match="girr:commandSet[girr:command/girr:parameters/@protocol = 'rc5']">
        <xsl:text>begin remote
&#9;name&#9;</xsl:text><xsl:value-of select="../@name"/>
<xsl:text>
&#9;bits&#9;13
&#9;flags&#9;RC5|CONST_LENGTH
&#9;eps&#9;30
&#9;aeps&#9;100
&#9;zero&#9;889&#9;889
&#9;one&#9;889&#9;889
&#9;plead&#9;889
&#9;gap&#9;90886
&#9;toggle_bit&#9;2
&#9;frequency&#9;36000
&#9;begin codes
</xsl:text>
<xsl:apply-templates select="//girr:command"/>
<xsl:text>&#9;end codes
end remote
</xsl:text>
</xsl:template>

<xsl:template match="girr:command[girr:parameters/@protocol='rc5']">
    <xsl:text>&#9;&#9;</xsl:text>
    <xsl:value-of select="@name"/>
    <xsl:text>&#9;0x</xsl:text>
    <xsl:value-of select="exporterutils:processBitFields(
                                    true(),  false(), number(girr:parameters/girr:parameter[@name='F']/@value), 1, 6,
                                    false(), false(), number(girr:parameters/girr:parameter[@name='T']/@value), 1, 0,
                                    false(), false(), number(girr:parameters/girr:parameter[@name='D']/@value), 5, 0,
                                    false(), false(), number(girr:parameters/girr:parameter[@name='F']/@value), 6, 0)"/>
    <xsl:text>
</xsl:text>
</xsl:template>

</xsl:stylesheet>
</exportformats:exportformat>

<!-- Here, additional export formats can be added if the user so desires.
Consider using XInclude for this, as in the following example. -->
<!--
<xi:include href="myexportformats:exportformats.xml">
    <xi:fallback/>
</xi:include>
-->
</exportformats:exportformats>
